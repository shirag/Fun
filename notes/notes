


C++
----

1. For string s, using s[index], you can not insert element into the string. You
   can just read. But, not write into it.
   Where as swap(a[10], b[10]) => is good.
2. For maps, the order of insertion is not maintained. e.g, when you iterate 
   over the map after insertion, you cant retrieve it in the order in which it 
   was inserted.
3. For maps always use find() to find if an element exists and never use []. You might end up over writing.
   For finding if a map contains one element mp.count() != 0 instead of mp.find != mp.end()
4. For looping over containers using iterators, use macros to keep it simple.

5. If you want to remove all the duplicates in a vector and sort them, 
   then copy the vector to a set and copy it to a vector back again. This will achieve what you want to achieve.
   
6. Never ever modify the key value while traversing a map.

7. The std::find() and std::count() take O(N). So, try avoiding them for set and map. 
   In those cases, use container's appropriate functions since they use O(log n)
      
9. string::erase(it) function always deletes the character at that location and 
   moves all character by one location to the front. So, after this operaton, it will 
   point to the same location. But, new content will occupy the same location. But then there no gurantee.
   So, its best to do something of the following and discrard any iterator that points to elements 
   after the element erased.

   
10. C++: tool box
    * string to int - stoi()
    * int to string - to_string()
    * Is a string palindrome: os == string(os.rbegin(), os.rend());
    * Max heap: priority_queue<int> q;
      Min heap: priority_queue<int, vector<int>, greater<int>> q;
        Second parameter: Container object is the second class template parameter 
        (the type of the underlying container for the priority_queue; by default: vector<T>).
        Third paramer is a functor. 
      Max heap creation using heap(O(n)): std::make_heap (v.begin(),v.end()), then push_heap and pop_heap();
    * If you want to store k top/max/largest values, then store it in a min heap of size k. If the value is larger than top, pop and then push new val.
      If you want to store k bottom/min/smallest values, then store it in a max heap of size k. If the value is smaller than top, then pop and then push new val.
      
      Problem          Heap    Condition to pop
      Top(Twitter)     Min     Greater
      Bottom           Max     Lesser   
      
    * You can not iterate over queue elements. You can accuess only front() and back()
    * To concatenate vector b to another one a: a.insert(a.end(), b.begin(), b.end());
    * To get substring from a string: string ss = s.substr(position, size);
    * To get smaller strings from a space separated bigger string:
      istringstream iss(mybigstring, istringstream::in);
      while( iss >> word ) {word1.push_back(word);}        
    * When you have a dictionary with key and multiple values for key,
      unordered_map<key,vector<int>> is the way to go. When you want to insert something
      auto it = mm.find(abs);
      if(it != mm.end())  it->second.push_back(val);
    * queue: push(x)
      queue: back() - reference to last pushed.
      queue: pop - remove front. 
      queue: front() - retrieve first element. 
      
      stack: push(x)
      stack: top() - reference to last pushed.
      stack: pop - remove top/last pushed. 

      list: push_front()
      list: push_back()
      list: pop_front()
      list: pop_back()

      priority_queue: push()
      priority_queue: pop()
      priority_queue: top()

11. Two problems with pointers:
    1. Memory it points to, is gone(dangling pointer).
    2. Pointer pointing to a memory is gone.
    With reference counting mechanism(a kind of smart pointer), the memory is not released if there is at least one referance.
12.  Smart pointers: They look like regular pointers. But they also release memory/object they are pointing, automatically.
     Smart pointers ensure that when an pointer pointing to an object is destoyed, the corresponding object is also destroyed.    
     e.g: Unique pointer(no copy allowed), shared pointer(ref counting mechanism), 
     weak pointer(pointing to shared, but does not have count towards ref count).
     
     Code snippet:
     
     int mySmartPointerDemo()
     {
         //with regular pointer
         int *ptr = new int(10);
         cout << *ptr << " \n" ;
         delete ptr;
         
         unique_ptr<int> ptr1(new int(10));

         return 0;
     }  
     If you try to copy unique pointers it will lead to compile time errors.

     
     
13. RAII: Resource acqusition is initialization: Locally created vectors dont have to destroyed. When an object goes out of scope,
    destructor gets called and releases memory resources.     
     
13. Can I have a virtual destructor? 
    To sum up, always make base classes' destructors virtual when they're meant to be manipulated polymorphically.
    If a class has any virtual function, then it should have a virtual destructor.
    If a class does not have any virtual function then it should NOT have a virtual destructor.
    This is because it will increase the size of the object by creating an extra vtable.
    A virtual destructor ensures that the objects resources are released in the reverse order of the 
     object being constructed w.r.t inherited object.
 
14. There is no such thing as virtual constructors.

15. Overloading is breadth. Overriding is going down(inheritance).

16. What is 'this' pointer? Inside a member function, 'this' returns the pointer to the member object.   

20. What is Return Value Optimization(RVO)?
    string fn1(string b)
    {
        string a;
        return a;
    }
    main()
    {
        string b = fn1();
      
    }
    If you dont enable RVO in this case, we might end up calling the copy contructor of string twice. If you enable RVo, then compiler 
    manipulates the code such that there is no copy. 
    void fn1(string& a)
    {
        a.append(); 
        return;
    }
    main()
    {
        string b;
        fn1(b);
  
    }
    When is it not applied? return cond ? first : second; (first and second are two strings)

24. How do you implement a factory class/method in C++?


25. Skip list advantage is you dont have to lock the entire linked list. in case of a tree you have to.
    Efficient alternative to balanced binary trees and easy to implement.
    Concurrency and locking is the key. 
    Srinivas Devadas, MIT video: https://www.youtube.com/watch?v=2g9OSRKJuzM
    
26. Object model is the framework. Four major elements of this model(Grady Booch);
    * Abstraction: Focusses on essential characteristics of some object. Identify similarities.
    * Encapsulation: hides the details of implementation of the object. Try to hide differences. 
    * Modularity: Packaging abstractions into discrete units.
    * Hierarchy: Ranking or ordering of abstractions.
      Inheritance is a "is-a" heirarchy. It implies a generalization/specialization heirarchy.
      Subclass specializes the behaviour of the super-class. Superclasses represent generalized abstractions.

-------------------------------------------------------------------------------------

17. C++
    1. C++ provides STL.
    2. Very hard to achieve inheritance in C.
    3. C does not provide exception handling.
    4. C does not have the concept of references.
    5. C does not allow function overloading.
    
18. What are virtual functions?
    Virtual functions are used to achieve polymorphism. Virtual functions are called according to the type of 
    object a pointer is pointing(referencing) to instead of type of the pointer(reference). 
    Virtual functions are resolved at runtime.   
    If a class has virtual functions then it is meant to be used a base class.
    
*   What is polymorphism?    
    Polymorphism gives you the ability to create one module calling another, and yet have the compile time
    dependency point against the flow of control instead of with the flow of control. By using polymorphism, a high level module does not depend on
    low-level module. Both depend on abstractions. This helps us to apply the dependency inversion. 
    
19. Difference between copy constructor and assignment operator.
    The copy constructor is for creating a new object. It copies a existing object to a newly constructed object    
    The assgignment operator is for assigning values to an existing object. This might mean desroying existing object.
    
*.  What is a pure virtual function?
    A pure virtual function or pure virtual method is a virtual function that is required to be implemented by a derived class 
    if the derived class is not abstract. Classes containing pure virtual methods are termed "abstract" and they cannot be instantiated directly.
    You achive this by not defining the function body in the base class and make = 0;
    
23. What are Abstract classes? Can you create an object of a abstract class?
    A class that contains atleast one pure virtual function is called abstract class.
    You cannot create an object of an abstract class type. Abstract classes act as expressions of general concepts 
    from which more specific classes can be derived. 
    
26. Initializer list: Its an efficient way of initializing all memeber variables of a class in a constructor. Member variables are 
    initialized using a copy constructor rather than by calling the default constructor and then a copy assignment operator.   
    There are certain cases where initializer lists are the only way of initializing class member data.
    1. initialization of non-static const data members. In the case of const data the object should be assigned a value before they can be contructed.
    2. Initialization of reference members.
    3. Initialization of data members that do not have default constructors.
  
31. What is friend function? Its not a memeber function of a class. but, it has access to all private and 
    protected members of a class.
    
32. What is operator overloading and function overloading in C++?
    Function overloading: You can have multiple definitions for the same function name in the same scope.
    The defintions differ by the number of arguments.
    Multiple declarations with the same function name, but different arguments and function defintions.
    You cant overload just by return value.
    
33. What are the opertators that can not be overloaded in C++?
    Scope resolution operator(::), Member selection operator(.*), dot operator(.), conditional operator(?:). 
   
34. What is name space? How would you use it?
    Namespace is a declarative region that provides a scope to the identifiers (names of the types, function, variables etc) inside it.
    using namespace std;

35. What is public, private and protected?
    public memebers can be accessed by anywehere outside the class within a program.
    private can be accessed only by class and friend functions.
    protected can be accessed by derived class and friend functions. 

36. What is inheritance? Whay would you inherit?
    Its a technique to reuse existing code. Process of creating new classes from existing classes. New classes inherit some of the properties and behaviours of 
    existing classes. 
    Public inheritance: public members of the base class become public members of the derived class and protected members of the
                        base class become protected members of the derived class.
    Protected inheritance: public and protected members of the base class become protected members of the derived class.
    Private inheritance: public and protected members of the base class become private members of the derived class.

37. Difference between a class and a structure.
    A class has all members private by default. A struct is a class where members are public by default. Thats it.

38. What is multiple inheritance? What is diamond problem in C++?
    An object or class can inherit characteristics and features from more than one parent object or parent class.
    The diamond problem occurs when two superclasses of a class have a common base class, this causes ambiguities.
    Person base class, derive student and teacher from the base, then you have TA derived from both. 
    now when you construct a TA class, it will call the base class constructor and destructor twice.    
    Solution is to use virtual for super classes.
    class Faculty : virtual public Person {}
    class Student : virtual public Person {}
     
    
39. What is the problem of inlining in recursive functions?
40. When is it appropriate to use templates?
    Templates are often used to:

    Create a type-safe collection class (for example, a stack) that can operate on data of any type.
    Add extra type checking for functions that would otherwise take void pointers.
    Encapsulate groups of operator overrides to modify type behavior (such as smart pointers).

    Most of these uses can be implemented without templates; however, templates offer several advantages:

    Templates are easier to write. You create only one generic version of your class or function instead of manually creating specializations.
    Templates can be easier to understand, since they can provide a straightforward way of abstracting type information.
    Templates are type-safe. Because the types that templates act upon are known at compile time, the compiler can perform type checking before errors occur.
    
41. How do you implement a singleton design pattern:    
    class playerManager
    {
        public:
            static playerManager& getInsance(){
                static playerManager instance;
                return instance;
            } 
        private:
            playerManager(){};
            playerManager(playerManager const&);   // Don't Implement.
            void operator=(playerManagerS const&); // Don't implemen
    };
    
    playerManager pm = playerManager::getInstance();
    
    * Make the constructor private. 
    * Make sure that you override the default copy constructor and assignment operator so that you can not make a copy of the singleton (otherwise it would not be a singleton).
    * You should never be able to free a singleton manually. How do you know who is keeping a reference to the singleton?
      If you don't know (or can't guarantee) nobody has a reference (in your case via a pointer) then you have no business freeing the object.
    * Use the static in a function method. This guarantees that it is created and destroyed only once. It also gives you lazy initialization for free. 
  
42. What are some of the salient features of C++ 11(Uber Q)    
    * auto is a place holder for type. Its type should be deduced from its initializer.
    * Range based for loops: This is useful when you want to access each element of array/collection and dont care about index/iterator/number of elements in the container.
    
-------------------------------------------------------------------------------------
Multi-threading:
 
   * What is mutli-threaded programming?
   * Can you declare a volatile for a structure?

   * Deadlock:
     Two (or more) threads have stopped execution or are spinning permanently. For example, a simple deadlock
     situation: thread 1 locks lock A, thread 2 locks lock B, thread 1 wants lock B and thread 2 wants lock A.

   * How can you prevent deadlocking from occurring?     
     You can prevent deadlocks from happening by making sure threads acquire locks in an agreed order
     (i.e. preservation of lock ordering). Deadlock can also happen if threads do not unlock mutexes properly.
     Some techniques to prevent it:
     * If you make sure that all locks are always taken in the same order by any thread, deadlocks cannot occur. 
     * Another deadlock prevention mechanism is to put a timeout on lock attempts meaning a thread trying to obtain a lock will only try for so long before giving up.
     * Deadlock detection is a heavier deadlock prevention mechanism aimed at cases in which lock ordering isn't possible, and lock timeout isn't feasible. 
       This can be achieved using maps or graphs.
     
   * Define: race condition
     A race condition is when non-deterministic behavior results from threads accessing shared data or resources 
     without following a defined synchronization protocol for serializing such access.
     
   * Priority inversion:
     A higher priority thread can wait behind a lower priority thread if the lower priority thread holds a lock for which the higher priority thread is waiting.
     
   * Thread Barriers:
      are a method to synchronize a set of threads at some point in time by having all participating threads in the barrier 
      wait until all threads have called the said barrier function. This, in essence, blocks all threads participating in the
      barrier until the slowest participating thread reaches the barrier call.
       
   * Spin Lock:       
     Spinlocks are locks which spin on mutexes. Spinning refers to continuously polling until a condition has been met.
     In the case of spinlocks, if a thread cannot obtain the mutex, it will keep polling the lock until it is free. 
   
   * Busy Wait:
     When one thread is waiting for another thread using an active looping structure that doesn't do anything. Example:
     Thread task = new TheTask();
     task.start();
     while( task.isAlive() ){
         ; // do nothing
     }
     This can be avoided using mutexes
     
   * Name three thread design patterns
     1. Thread pool (Boss/Workers)
     2. Peer (Work crew)
     3. Pipeline
     
   * Explain how a thread pool works  
     One thread dispatches other threads to do useful work which are usually part of a worker thread pool. 
     This thread pool is usually pre-allocated before the boss (or master) begins dispatching threads to work.
     Although threads are lightweight, they still incur overhead when they are created. If the boss thread becomes a worker thread once 
     it's done starting other worker threads then this is a Peer Thread Design Pattern.
     
   * What are four mutex types? 
      - Recursive: allows a thread holding the lock to acquire the same lock again which may be necessary for recursive algorithms.
      - Queuing: allows for fairness in lock acquisition by providing FIFO ordering to the arrival of lock requests.
        Such mutexes may be slower due to increased overhead and the possibility of having to wake threads next in line that may be sleeping.
      - Reader/Writer: allows for multiple readers to acquire the lock simultaneously. If existing readers have the lock, a 
        writer request on the lock will block until all readers have given up the lock. This can lead to writer starvation.
      - Scoped: RAII-style semantics regarding lock acquisition and unlocking.

-------------------------------------------------------------------------------------
Linux OS:
 * Difference between a thread and a process:
   * One or more threads run in the context of the process. 
   * Both processes and threads are independent sequences of execution. 
   * Threads (of the same process) run in a shared memory space, while processes run in separate memory spaces.
   * A thread can execute any part of the process code, including parts currently being executed by another thread.
   
 * Memory Management:
   * Virtual memory makes it look as if there is lot more memory in the system than what really is. 
   * Virtual address space is typically divided into 8K sized pages.
   * Page Tables map virtaul address to phusical address.
   * Valid page fault: Process tries to access a virtual address that is not present in memory.
   * Invalid page fault: Process tries to access a virtual address that is not valid inside its address space also.
   * Demad paging: Loading a only a part of the virtual memory into physical memory initially and loading the rest later
                   as and when the need arises is called Demad paging.
   * Swapping: When a new process want to get into memory and there is not enough memory, the old one needs to evacuvated. 
               LRU caching techniques are used to get rid of older ones.                
   * Physical/Virtual addressing mode: When in physical addressing mode, you dont use virtual tables and and virtuall addresses.
          This is very useful for running OS etc. ITs very hard for OS to maintian a virtual table for itself.           
   * Swap space: in Linux is used when the amount of physical memory (RAM) is full. If the system needs more memory resources
     and the RAM is full, inactive pages in memory are moved to the swap space. While swap space can help machines with a
     small amount of RAM, it should not be considered a replacement for more RAM.
   * Roughly, swap space plus physical memory gives you your total possible virtual memory space
   * Memory usage tools: free, top, (ps aux) and ps_mem.py
   * OOM kiler: it is the job of the linux 'oom killer' to sacrifice one or more processes in order to free up memory for the system when all else fails.
   * ps_mem.py: 
     * Tries to determine how much RAM is currently being used per program. Note per _program_, not per process. 
       So for example this script will report RAM used by all httpd process together. 
     * determine how much RAM is currently being used per program, is useful when top command 
       failed to report actual memory shared due to copy-on-write among multiple processes. 
   * Linux Page cache:
     The role of the Linux page cache is to speed up access to files on disk   
   * Shared memory(olden way) 
     * One process creates a segment using  
       shmget(key, SHMSZ, IPC_CREAT | 0666)
     * Once created, a shared segment can be attached to a process address space using shmat()
       shm = shmat(shmid, NULL, 0)) == (char *) -1) 
     * Shared memory(newer way)     
       fd = open("foo", O_RDONLY);
       pagesize = getpagesize();
       data = mmap((caddr_t)0, pagesize, PROT_READ, MAP_SHARED, fd, pagesize);
    
-------------------------------------------------------------------------------------
 * DNS: They maintain a directory of domain names and translate them to Internet Protocol (IP) addresses. 
        Domain Name Servers (DNS) are the Internet's equivalent of a phone book. 
        This is necessary because, although domain names are easy for people to remember, computers or machines, access websites based on IP addresses.
         
 * NAT: Network address translation (NAT) is a method of remapping one IP address space into another.
        This is done by modifying network address information in Internet Protocol (IP) datagram packet 
        headers while they are in transit across a traffic routing device.
        NAT devices are needed for security and IPv4 limitations on available public IP addresses.

 * ARP: Used to map IP network addresses to the hardware addresses used by a data link protocol.

-------------------------------------------------------------------------------------
Scott Meyers:

28. Why is it a bad idea for destrucotrs to throw exception?
    try{ 
        vector<int> v; 
        fn1();
    }
    Now imagine fn1() throws an exception and then if vector<int>'s destructor also throws an exception, 
    then it is perfect receipe for a disaster.


27. Four functions that compiler generates for you: constructor, destructor, copy assignemnt, copy constructor.      

33. Always prefer psss const pass-by-reference over pass by value. Exceptions are: built-in variables and iterators.
    Iterators are very small. So, there is no advantage to passing by reference.


*. Design guidelines:
    1. Make interfaces such that it is easy to use correctly and hard to use incorrectly.    
    
   Public means uncapsulated which means unchangeable. 

29. Never call virtual functions in constructor/destructor becaseu this will end up calling the base class constructor 
    and never go to derived part.    
    
30. Assignment operator should return *this. This way we can do x = y = z;(y = z should return *this/y)    

32. In C++ iterators are implemented as pointers internally.


34. Problems in returning a reference: 
    stack allocated: you are pointing to nowhere.
    Heap allocated: YOu may not have the right reference to it.
    allocated using static inside a function: thread safety + other issues.
    Overall very bad idea to have a function that returns a reference. Always return by value/object.   

        
-------------------------------------------------------------------------------------
Design Patterns:

* Four types of design patterns: 
    * Creational - Factory 
    * Structural - Proxy
    * Behavioral - Observer, Mediator, Memento
    * Concurrency - Scheduling    
    

* Design patterns:
    1. Name 2. Problem(context where it might be applied). 3. Solution(defines objects and describes how they interact). 
    4. Consequences: Results and tradeoffs.   


----------------------------------------------------------------------------------
Array/string sizes and index

no of elements/size(including current index) = currIndex - startIndex;
no of elements/size(excluding current index) = currIndex - startIndex - 1;

Dummy nodes/Sentinel: very good when you want to have a dummy node in front of a linked list

---------------------------------------------------------------------------------
Bit wise operator:
1. Turn ON a bit(HONOR)
   x |= 0x01 => LSB is turned ON.
   x |= (1 << n) => nth bit in the variable x is turned ON. n = 0 to 7.
        (x >> n) => x is moved to RIGHT by n no of moves.
2. Turn OFF a bit(OFFENDNOT)
   x &= ~(1 << n) => nth bit is turned OFF. n = 0 to 7.
3. To test a bit is ON.
   if(x & (1 << n)) => TRUE is nth bit is ON
4. Toggle a bit:
   x ^= (1 << n) => nth bit is flipped/toggled.
   
5.        OR   AND  XOR(when two are distinct)
    0  0   0   0    0   
    0  1   1   0    1
    1  0   1   0    1
    1  1   1   1    0
    
    
---------------------------------------------------------------------------------
C/Embedded interview questions:

*  Never do the following(wasted an hour on this):
   for(unsigned char i = 0; i <= 255; i++){
   }
   Your for loop is spinning forever as i is always between 0 and 255.
*. What are the problems with C macros?
   1. They are not typesafe. There is nothing preventing you from passing in a character to 
      a macro that was desgined for int.
   2. Expressions passed to macros might evaluate more than one time.     
   3. C++ min macr is type safe.
  
*  C various declarations:
   1. An  array of 10 pointers to integers: int *ptr[10]
   2. A pointer to an array of 10 integers: int (*ptr)[10];
   3. A pointer to a function that takes an integer as an argument and returns an integer: 
      typedef int (*func_p)(int)  ;
      int myFunction(int){}
      func_p fp = myFunction;
    4. An array of 10 pointers to functions that takes an integer as an argument and returns an integer: 
      typedef int (*func_p)(int)  ;
      func_p fp[10]; 
*  What is local, static and global variables?
   local variables  - lifetime: inside the function, visibility- inside the function. Stored in stack.  
   static variables - lifetime: entire program, visibility- inside the function/inside the file. Stored in .    
   global variables - lifetime: entire program, visibility- entire code.     
                      initialized global constant variable -----> stored in data segment.
                      uninitialized global constant variable -----> stored in bss segment.
                                                                                      
      
*  What do you mean by volatile:
   The value of this field might change outside this program without the compiler being aware of. 
   So, you are telling the compiler dont cache this value and always read it from memory.
   
*  Variable should be declared volatile whenever its value could change unexpectedly. In practice, only three types of variables could change:
   1. Memory-mapped peripheral registers
   2. Global variables modified by an interrupt service routine
   3. Global variables accessed by multiple tasks within a multi-threaded application
   
* How does a malloc work?
  *  Get a block of memory from the OS through sbrk() (Unix call).
  *  Create a header and a footer around that block of memory with some information such as size, permissions, and where the next and previous block are.
  *  When a call to malloc comes in, a list is referenced which points to blocks of the appropriate size.
  *  This block is then returned and headers and footers are updated accordingly.
  *. When a prgram frees the memory allocated using malloc, memory mgment unit does not return it to system memory immediately. 
     It has free list. It adds the memory to free list. This will prevent any fragementation that can take palce.
  *  2nd explanation: Your process has a region of memory, from address x to address y, called the heap. All your malloc'd data lives in this area.
     malloc() keeps some data structure, let's say a list, of all the free chunks of space in the heap. When you call malloc,
     it looks through the list for a chunk that's big enough for you, returns a pointer to it, and records the fact that 
     it's not free any more as well as how big it is. When you call free() with the same pointer, free() looks up how big that 
     chunk is and adds it back into the list of free chunks(). If you call malloc() and it can't find any large enough chunk in the heap,
     it uses the brk() syscall to grow the heap, i.e. increase address y and cause all the addresses between the old y and the new y 
     to be valid memory. brk() must be a syscall; there is no way to do the same thing entirely from userspace.
  * Malloc typically requests memory from OS in terms of page block(4K).   


* DMA transfer begins
  * Cache content is not valid for the DMA buffer
  * DMA transfer is done. Processor is notifed with an intrrupt.
  * ISR is invoked. Context switch causes cache to be invalidated.
  * When you return from ISR you do a context swtitch again and you should be able to do a valid read from a DMA buffer.
  * Hardware ddoes all the cache management.

* ISR context: Supervisor/privileged context is where the ISR runs.
* Mask interrupts if they are irritiating you
* How do you achieve executing flash at the same time you are downloading?
  1. You have an external flash and internal flash.
  2. Code is running off internal flash at any time.
  3. External flash has two sections: One for current running code image and the other for any new image.
  4. When there is a new image, it gets downloaded into the external flash's appropriate section.
  5. Bootloader now runs off RAM and then it loads the new image onto the internal flash.
  6. After loading the new image onto internal flash, bootloader transfers control to the newly loaded internal flash image.
  7. If anything is problem with newly loaded image then bootloader erases the newly loaded image and transfers the old image.
---------------------------------------------------------------------------------

Embedded Linux:
  *. Same kernel as regular Linux. Lesser packages.
  *. Buildroot is a tool that simplifies and automates the process of building a complete Linux system for an embedded system, using cross-compilation.
     * The first step when using Buildroot is to create a configuration. You can do thsi using menuconfig. It is s nice configuration tool similar to the
       one you can find in the Linux kernel or in BusyBox.
  *. GDB debugging: A debugger mainly used for looking at backtrace and callstack.       
  *. Two options to run: Running off of flash. or running off of NFS. If its NFS then it would use the host machine for root files system.
  *. GNU Build system(helps with portability of source code to many unix like systems) consists of: 
     Autoconf: Autoconf is a tool for producing configure scripts for building, installing and packaging software on computer systems.
     Automake: aims to allow the programmer to write a makefile in a higher-level language, 

---------------------------------------------------------------------------------
C++ memory model/Concurrency:

Producer-Consumer problem:
Two main problems:
1. Producer should sleep when the buffer is full. Consumer should sleep when the buffer is empty.
   Consumer should wake up there is 1 unit of data in the buffer. Producer should wake up when there
   is one unit of space available in the buffer. We should achieve this by producer and consumer 
   sending signal to each other. If this is not done properly we might end up sleeping forever.
2. You should properly protect the field that indicates how much data is present in a buffer using a 
   proper mutex. 
   
   For one you should use a condition variables. But, then condition variables also have to be properly
   protected using a mutex.
   
3. Primitives for protecting access to portions of memory: Mutex
   Primitives for allowing synchronization(block one thread until the other one does something) 
     between threads: Condition Variables. 
   A condition variable must always be paired with a mutex. When it waits for a mutex, it gives up the condition variable. 
   when the condition is met, it automatically gets themutex back again.   
      
4. Deadlock: Two threads waiting for a resource the other thread has. Infinite wait.
   Livelock: Each deadlocked thread releases the acquired resource and does something else. After sometime deadlock repeats.
             Then they go back to release the resource. They will back and forth forever like this. Lots of wasted cpu cylces.  
   Starvation: One thread has a resource and holds onto it forever. The other thread just keeps waiting. The one that is waiting 
             is basically starving.          

---------------------------------------------------------------------------------
Video Notes:

H.264:
 1. What are frames? I, P and B.
    Independent frame. Least compresed. You dont need other frames to decode it.
    P frame. Needs previous frames to decode it. It uses the I frame that comes before it to decode the frame. More compressed that IFrame
    B frame. can use previous a forward to decode it. It uses the I frame that comes before it and after it to decode itself. Most compressed.
    A slice: It is more spatial term. Is a spatially distinct region of a frame that is encoded separately from any other region in the same frame. 
    There are I-slices, P-slices, and B-slices.
 2. Profiles and levels?
    Profiles address the problem of code complexity and processing power.
    BMH:
    CEll phone use baseline
    STBs use Main Profile.
    Blueray uses high profile.
    Levels address the problem of bandwidth, max resolution, and memory issues on the decoder side
    Low end device(processor and memory), low bitrate, small screen size: go for baseline profile and lower levels
    High end device(processor and memory), high bitrate, bigger screen size: go for aseline profile and lower levels
     
 3. How do you reduce data?  Within and image and within a series of images.
 4. What is block based coding? Or what are macroblocks?
    Macro block is a processing unit.
 5. What block based motion compensation? What is coding the motion vector? (P frames)
 6. What is intra-prediction?
 * Most efficient encoder. In terms of bit-rate.
 * Also very high resilience to error.
 
HLS:

DASH:
  Media Presentation Desription File contains link to period description files.
  Period files contain link to Adapatation description files(camera angle, language etc).
  Adaptation description files contain link to bitrate info files.
  Bit rate info files contain link to actual video files(fragemented Mp4 files)
  
Comparison between HLS and MPEG DASH:
  HLS is sclable, Hard with MSE, and highest latency.
  Why high latency? The player needs at least 3 segments to start the playback, 
    so you can use segments of 1s length with keyframes each second.
    This has disadvantages as it increases the stream size due to more frequent keyframes, adds a lot of overhead 
    and requires more frequent playlist refreshes thus increasing the number of HTTP requests.
    
    If you keep the default ts segment size of 10 seconds, then you are wasting 10 seconds in generating the first ts segment itself. 
    If you say min 3 segments are needed in the queue, then you are talking about 30 seconds latency there itself.
  
  MPEG DASH: Standardized. Supports MSE and latency better than HLS. RTP(UDP) and RTMP(TCP) offer better latency. Scalable.
  RTMP: Very low latency. But not scalable.
    
MP4:


* Acceptable 1080p stream using H.264 (AVC) compression at around 6 Mbps. 
  All else being equal, a 4K video would require 4x the bandwidth of a 1080p video (24 Mbps).
  With efficient Codec you can bring it down to 15mbps. With Mediamelon you can bring it to 10mbps.
  
  
* Latest Video  - HLS/DASH using MSE. 
                  Codes: VP9, HEVC h.265 for low latency video coding, and then there is AV1 codec which is 20% more efficient than VP9. 
                  
* What all CODEC configurations we do at OTV?   
  H.265: 
      /* Copy start code for Video Parameter Set. */
      /* Copy Video Parameter Set. */
      /* Copy start code for Sequence Parameter Set.(SPS) */
      /* Copy Sequence Parameter Set. */
      /* Copy start code for Picture Parameter Set.(PPS) */
      /* Copy Picture Parameter Set. */

* NAL: is a codec format for sending data over the network.
* VCL(Video Control Layer) and Non-VCL NAL Units      
    The VCL NAL units contain the data that represents the values of the samples in the video pictures, 
    and the non-VCL NAL units contain any associated additional information such as parameter sets
    (important header data that can apply to a large number of VCL NAL units) and supplemental enhancement information
     (timing information and other supplemental data that may enhance usability of the decoded video signal but are not 
     necessary for decoding the values of the samples in the video pictures).

   The SPS and PPS are both types of NAL units.    
   The SPS NAL unit contains parameters that apply to a series of consecutive coded video pictures, referred to as a “coded video sequence” in the h.264 standard. 
   The PPS NAL unit contains parameters that apply to the decoding of one or more individual pictures inside a coded video sequence.



* Norbert questions:

  * What is prerolling from device point of view?
  * How does Iframe only mode work?
  * fmp4 against regular MP4 
  * How do you initialize flow proxy and decoder proxy? What is the difference at a high level?
  * How do we play with buffering level etc in the case of newer pipeline?
    Water mark model?
    In our case when would we show the spinning wheel"
    High water mark and lowe water mark: We start playing when we reach the high water mark. 
    But, we would pause when we go below the low water mark. Wait unti we hit the high water mark gain.
  * Licensing terms.
  * Do you know anything about GStreamer's streaming threads.
  * We were disabling prerolling after the first playback. Becuase of this after a seek we were not 
    able to wait for ASYNC_DONE message.
  
  
-----------------------------------------------------------------------------------------------------------------------------------    

UTF/Unicode


-----------------------------------------------------------------------------------------------------------------------------------    
  
    
-----------------------------------------------------------------------------------------------------------------------------------    
  * Networking:
   Unicast: from one source to one destination i.e. One-to-One 
   Broadcast: from one source to all possible destinations i.e. One-to-All 
   Multicast: from one source to multiple destinations stating an interest in receiving the traffic i.e. One-to-Many 
   
   * TCP(trasmission control protocol) and UDP(user datagram protocol) and transport layer protocols.
   * IP is network layer protocol.
   * TCP is connection oriented. UDP is connection less.
   * TCP is about reliability, UDP is about speed(faster with best-effort protocol).   
   * TCP ensures that that comes in order. UDP does not ensure that. Applcation has to ensure that.
   * TCP is heavy weight. UDP is light weight. TCP takes two packets for setting up the connection itself.
   * TCP provides flow control(sliding wndow protocol). i.e if the sender is sending too fast then you can always ask the sender to sent it slow.
     This way slower devices can talk to faster network.
   * TCP on the sending side uses the congestion control(uses a congestion window). 
   
   Why TCP against UDP for VoD streaming:
   1. TCP provides reliability. Sends the packet again if there is a drop of packet.
   2. TCP provides network buffers.
   3. TCP connections oriented. So, helps with security.
   4. TCP's bandwidth probing and congestion control will attempt to use all of the available 
      bandwidth between server and client, fetching content as quick as possible while being friendly
      to other (TCP) traffic on the same links.
      
   Other advantages of TCP:
   * in-order delivery of data to the application. 
   * Since TCP builds a buffer, TCP also has to ensure that its buffer does not overflow. This is ensured using 
     flow-control where receiver tells the sender if the buffer is full.
   * TCP offers congestion control. It means keeps increasing its send buffer window sizes until 
     it sees packet drops.  
   * With TCP server needs a socket connection for every TCP receivert where as with UDP server can talk to multiple UDP receivers
     using the same socket.   
      
   RTSP: Realtime streaming protocol. Session control protocol for streaming video. TCP based.(Application level)
   RTP: Realtime Trasport protocol. used with RTSP to stream video data. UDP based.(Application level)
   RTCP: Realtime Trasport Control protocol. Goes with RTP. It provides QoS for RTP(gather stat).
   RTMP: Realtime Messaging protocol. RTMP is a TCP-based protocol which maintains persistent connections and allows low-latency communication.
         Unlike HLS, RTMP uses a push model. Instead of the player requesting each segment, the server continuously sends video and audio data
         
   WebRTC: WebRTC can be used for multiple tasks, but real-time peer-to-peer audio and video (i.e., multimedia) communications is the primary benefit. 
           WebRTC allows a desktop or mobile browser-based application to access the device’s microphone and video camera.  
           WebRTC uses RTP to transfer audio and video.
   SRTP (Secure Real-Time Transport Protocol or Secure RTP) is an extension to RTP (Real-Time Transport Protocol) that incorporates 
   enhanced security features. Like RTP, it is intended particularly for VoIP (Voice over IP) communications.
   STUN (Session Traversal Utilities for NAT): one way for your devide to query its public facing IP from the NAT device.
     
   What is the difference between HTTP POST and PUT
   PUT is replacing the current website(look and feel). Shivani - Put is update. I want to add.
   Post is adding some content to fields of a document. POST is modify an existing field. I want to change my address.
   
   The steps involved in establishing a socket on the client side are as follows:
   * Create a socket with the socket() system call
   * Connect the socket to the address of the server using the connect() system call
   * Send and receive data. There are a number of ways to do this, but the simplest is to use the read() and write() system calls.
   The steps involved in establishing a socket on the server side are as follows:
   * Create a socket with the socket() system call
   * Bind the socket to an address using the bind() system call. For a server socket on the Internet, an address consists of a port number on the host machine.
   * Listen for connections with the listen() system call
   * Accept a connection with the accept() system call. This call typically blocks until a client connects with the server.
   * Send and receive data
-----------------------------------------------------------------------------------------------------------------------------------

Bufferuing Using Gstreamer:
1. Application PAUSES the pipeline when it sees a buffering % below 100%.
2. Application PLAYSBACK using the pipeline when it sees a buffering = 100%.
* How does the application receive this message? The pipeline has to send it. How does the pipeline do it?
  It can have a low and high water mark. When the buffer level hits the high water mark, we can send the 100% message. 
  When it goes below the low water mark, it sends less than 100% message. It will wait until hits the high water mark again to send 100%.
* How do you configure the low and high water marks?
  1. Fixed time: We always want buffer for these many seconds.
  2. Fixed size: We always want buffer these many bytes.
* NULL state: Default state.
* READY state: Default resources(run-time libraries and memory) available. NULL to ready, allocate all non-stream specific resources.
* PAUSED state: It is ready and can handle data.    

GStreamer High Level Flow:
1. Initialize an element(class init/bin init)
2. Set properties.
3. State Trasitions: Tells when to allocate resources.
                      NULL to ready - Memory, library etc(All proxies: resman, winman, flowproxy).
                      READY to PAUSED - Decoder resource allocation.
                       
4. Once in paused state, it can receive events(seek, caps, newsegment event)
   caps event: says what kind of decoder it is?
   newsegment event:indicates samples from new duration.
5. Chain calls: Receives video samples..
6. Now you can send messages to bus.
7. Answer any query like duration etc.
8. somebody can do a get property call.

* Scheduling mode: At OTV We did a push based shceduling mode. The src element would create a thread and push. Src pad would receive the chain function and in turn do a 
  a push of data on their sink pad.
  Pull based mode, the src pad would start a task and every src pad would support a function where you would get a range of bytes. 
  This would be used in cases where downstream element wants the control the data flow and requests only those many byes from the 
  upstream element.



/***********************************************************************************************************************/
 Architect!a!world6wide!video!distribution!system !![FaceBook Live]
 publshing workflow: Eager load or lazy loading.Upon  acahed miss push it to CDN.
                      what is the criterion for pushing?  
 playback workflow.
   
 
 1. Determine!which!parts!of!the!problem!are!important!and!will!affect!the!overall!design.!
    * Concurrent viewers(PCV), Infrastructure, low latency, is it live or recorded content? what kind of devices you are planning on showing to?
 
 2. Describe the system at a high level, explaining the overall architecture.
    ABR for heteriginialiyt of devices and network conditions.
 
 3. Explain!and!focus!which!pieces!of!the!system!are!most!interesting!or!difficult!to!design
    * How do you design the server 
    * The choice of protocol between the content provider and the data centre
      The choice of protocol between the content PoP and the device.
      the video chunk duration etc.
    * How many types of encoding to use and the file storage.  
    
 4. Draw!diagrams!that!clearly!describe!the!relationship!among!different!system!components.!  
 
 5. Identify!trade6offs!in!your!design!(such!as!consistency,!availability,!partitioning,!
    performance),!and!describe!how!you!make!a!decision!around!them.!
    * Startup time against the buffering. You dont want to send a lot of data because the userm any not choose to watch the entire content.
    * Adaptive streaming against
      Pros: Reduction of the delivery bandwidth cost.   
      Cons: Video should be transcoded into multiple live streams. Computing resources cost money.
    
    * Do you really want to use CDN- Cost is high.
    * TCP based protocol/UDP based protocols - tradeofs?
    
    
 6. Calculate!back6of6the6envelope!and!physical!resources!necessary.!
 
 7. Adjust!the!design!of!your!system!when!requirements!or!constraints!change.!
 
 8. Determine!how!your!system!will!perform!at!Facebook's!scale,!and!identify!any!bottlenecks!
    and!limitations!in!your!design.!
    
 9. Explain!how!your!system!handles!both!success!and!failure!cases.!
 
/***********************************************************************************************************************/
  Architect!a!world6wide!video!distribution!system !![Netflix VOD]
   1. Determine!which!parts!of!the!problem!are!important!and!will!affect!the!overall!design.!
    * Concurrent viewers(PCV), Infrastructure, low latency, is it live or recorded content? what kind of devices you are planning on showing to?
 
 2. Describe the system at a high level, explaining the overall architecture.
    ABR for heteriginialiyt of devices and network conditions.
 
 3. Explain!and!focus!which!pieces!of!the!system!are!most!interesting!or!difficult!to!design
    * How do you design the server 
    * The choice of protocol between the content provider and the data centre
      The choice of protocol between the content PoP and the device.
      the video chunk duration etc.
    * How many types of encoding to use and the file storage.  
    
 4. Draw!diagrams!that!clearly!describe!the!relationship!among!different!system!components.!  
 
 5. Identify!trade6offs!in!your!design!(such!as!consistency,!availability,!partitioning,!
    performance),!and!describe!how!you!make!a!decision!around!them.!
    * Startup time against the buffering. You dont want to send a lot of data because the userm any not choose to watch the entire content.
    * Adaptive streaming against
      Pros: Reduction of the delivery bandwidth cost.   
      Cons: Video should be transcoded into multiple live streams. Computing resources cost money.
    
    * Do you really want to use CDN- Cost is high.
    * TCP based protocol/UDP based protocols - tradeofs?
    
    
 6. Calculate!back6of6the6envelope!and!physical!resources!necessary.!
 
 7. Adjust!the!design!of!your!system!when!requirements!or!constraints!change.!
 
 8. Determine!how!your!system!will!perform!at!Facebook's!scale,!and!identify!any!bottlenecks!
    and!limitations!in!your!design.!
    
 9. Explain!how!your!system!handles!both!success!and!failure!cases.!



