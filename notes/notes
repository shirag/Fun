

C++
----

1. For string s, using s[index], you can not insert element into the string. You
   can just read. But, not write into it.
   Where as swap(a[10], b[10]) => is good.
2. For maps, the order of insertion is not maintained. e.g, when you iterate 
   over the map after insertion, you cant retrieve it in the order in which it 
   was inserted.
3. For maps always use find() to find if an element exists and never use []. You might end up over writing.
   For finding if a map contains one element mp.count() != 0 instead of mp.find != mp.end()
4. For looping over containers using iterators, use macros to keep it simple.

5. If you want to remove all the duplicates in a vector and sort them, 
   then copy the vector to a set and copy it to a vector back again. This will achieve what you want to achieve.
   
6. Never ever modify the key value while traversing a map.

7. The std::find() and std::count() take O(N). So, try avoiding them for set and map. 
   In those cases, use container's appropriate functions since they use O(log n)
      
9. string::erase(it) function always deletes the character at that location and 
   moves all character by one location to the front. So, after this operaton, it will 
   point to the same location. But, new content will occupy the same location. But then there no gurantee.
   So, its best to do something of the following and discrard any iterator that points to elements 
   after the element erased.

   
10. C++: tool box
    * string to int - stoi()
    * int to string - to_string()
    * Is a string palindrome: os == string(os.rbegin(), os.rend());
    * Min heap: priority_queue<int, vector<int>, greater<int>> q;
      Second parameter: Container object is the second class template parameter 
      (the type of the underlying container for the priority_queue; by default: vector<T>).
    * If you want to store k top/max/largest values, then store it in a min heap of size k. If the value is larger than top, pop and then push new val.
      If you want to store k bottom/min/smallest values, then store it in a max heap of size k. If the value is smaller than top, then pop and then push new val.
      
    * You can not iterate over queue elements. You can accuess only front() and back()
    * To concatenate vector b to another one a: a.insert(a.end(), b.begin(), b.end());
    * To get substring from a string: string ss = s.substr(position, size);
    * To get smaller strings from a space separated bigger string:
      istringstream iss(mybigstring, istringstream::in);
      while( iss >> word ) {word1.push_back(word);}        
    * When you have a dictionary with key and multiple values for key,
      unordered_map<key,vector<int>> is the way to go. When you want to insert something
      auto it = mm.find(abs);
      if(it != mm.end())  it->second.push_back(val);
    * queue: push(x)
      queue: back() - reference to last pushed.
      queue: pop - remove front. 
      queue: front() - retrieve first element. 
      
      stack: push(x)
      stack: top() - reference to last pushed.
      stack: pop - remove top/last pushed. 

      list: push_front()
      list: push_back()
      list: pop_front()
      list: pop_back()

      priority_queue: push()
      priority_queue: pop()
      priority_queue: top()

11. Two problems with pointers:
    1. Memory it points to, is gone(dangling pointer).
    2. Pointer pointing to a memory is gone.
    With reference counting mechanism(a kind of smart pointer), the memory is not released if there is at least one referance.
12.  Smart pointers: They look like regular pointers. But they also release memory/object they are pointing, automatically.
     Smart pointers ensure that when an pointer pointing to an object is destoyed, the corresponding object is also destroyed.    
     e.g: Unique pointer(no copy allowed), shared pointer(ref counting mechanism), 
     weak pointer(pointing to shared, but does not have count towards ref count).
     
     Code snippet:
     
     int mySmartPointerDemo()
     {
         //with regular pointer
         int *ptr = new int(10);
         cout << *ptr << " \n" ;
         delete ptr;
         
         unique_ptr<int> ptr1(new int(10));

         return 0;
     }  
     If you try to copy unique pointers it will lead to compile time errors.

     
     
13. RAII: Resource acqusition is initialization: Locally created vectors dont have to destroyed. When an object goes out of scope,
    destructor gets called and releases memory resources.     
     
13. Can I have a virtual destructor? 
    To sum up, always make base classes' destructors virtual when they're meant to be manipulated polymorphically.
    If a class has any virtual function, then it should have a virtual destructor.
    If a class does not have any virtual function then it should NOT have a virtual destructor.
    This is because it will increase the size of the object by creating an extra vtable.
    A virtual destructor ensures that the objects resources are released in the reverse order of the 
     object being constructed w.r.t inherited object.
 
14. There is no such thing as virtual constructors.

15. Overloading is breadth. Overriding is going down(inheritance).

16. What is 'this' pointer? Inside a member function, 'this' returns the pointer to the member object.   

17. C/C++
    1. C++ provides STL.
    2. Very hard to achieve inheritance in C.
    3. C does not provide exception handling.
    4. C does not have the concept of references.
    5. C does not allow function overloading.
    
18. What are virtual functions?
    Virtual functions are used to achieve polymorphism. Virtual functions are called according to the type of 
    object a pointer is pointing(referencing) to instead of type of the pointer(reference). 
    Virtual functions are resolved at runtime.   
    If a class has virtual functions then it is meant to be used a base class.
    
19. Difference between copy constructor and assignment operator.
    The copy constructor is for creating a new object. It copies a existing object to a newly constructed object    
    The assgignment operator is for assigning values to an existing object. This might mean desroying existing object.
    
20. What is Return Value Optimization(RVO)?
    string fn1(string b)
    {
        string a;
        return a;
    }
    main()
    {
        string b = fn1();
      
    }
    If you dont enable RVO in this case, we might end up calling the copy contructor of string twice. If you enable RVo, then compiler 
    manipulates the code such that there is no copy. 
    void fn1(string& a)
    {
        a.append(); 
        return;
    }
    main()
    {
        string b;
        fn1(b);
  
    }
    When is it not applied? return cond ? first : second; (first and second are two strings)
    
*.  What is a pure virtual function?
    A pure virtual function or pure virtual method is a virtual function that is required to be implemented by a derived class 
    if the derived class is not abstract. Classes containing pure virtual methods are termed "abstract" and they cannot be instantiated directly.
    You achive this by not defining the function body in the base class and make = 0;
    
23. What are Abstract classes? Can you create an object of a abstract class?
    A class that contains atleast one pure virtual function is called abstract class.
    You cannot create an object of an abstract class type. Abstract classes act as expressions of general concepts 
    from which more specific classes can be derived. 

24. How do you implement a factory class/method in C++?

25. Skip list advantage is you dont have tolock the entire linked list. in case of a tree you have to.
    Efficient alternative to balanced binary trees and easy to implement.
    
26. Initializer list: Its an efficient way of initializing all memeber variables of a class in a constructor. Member variables are 
    initialized using a copy constructor rather than by calling the default constructor and then a copy assignment operator.   
    There are certain cases where initializer lists are the only way of initializing class member data.
    1. initialization of non-static const data members. In the case of const data the object should be assigned a value before they can be contructed.
    2. Initialization of reference members.
    3. Initialization of data members that do not have default constructors.
  

31. What is friend function? Its not a memeber function of a class. but, it has access to all private and 
    protected members of a class.
    
32. What is operator overloading and function overloading in C++?
    Function overloading: You can have multiple definitions for the same function name in the same scope.
    The defintions differ by the number of arguments.
    Multiple declarations with the same function name, but different arguments and function defintions.
    You cant overload just by return value.
    
33. What are the opertators that can not be overloaded in C++?
    Scope resolution operator(::), Member selection operator(.*), dot operator(.), conditional operator(?:). 
   
34. What is name space? How would you use it?
    Namespace is a declarative region that provides a scope to the identifiers (names of the types, function, variables etc) inside it.
    using namespace std;

35. What is public, private and protected?
    public memebers can be accessed by anywehere outside the class within a program.
    private can be accessed only by class and friend functions.
    protected can be accessed by derived class and friend functions. 

36. What is inheritance? Whay would you inherit?
    Its a technique to reuse existing code. Process of creating new classes from existing classes. New classes inherit some of the properties and behaviours of 
    existing classes. 
    Public inheritance: public members of the base class become public members of the derived class and protected members of the
                        base class become protected members of the derived class.
    Protected inheritance: public and protected members of the base class become protected members of the derived class.
    Private inheritance: public and protected members of the base class become private members of the derived class.

37. Difference between a class and a structure.
    A class has all members private by default. A struct is a class where members are public by default. Thats it.

38. What is multiple inheritance? What is diamond problem in C++?
    An object or class can inherit characteristics and features from more than one parent object or parent class.
    The diamond problem occurs when two superclasses of a class have a common base class, this causes ambiguities.
    Person base class, derive student and teacher from the base, then you have TA derived from both. 
    now when you construct a TA class, it will call the base class constructor and destructor twice.    
    Solution is to use virtual for super classes.
    class Faculty : virtual public Person {}
    class Student : virtual public Person {}
     
    
39. What is the problem of inlining in recursive functions?
40. When is it appropriate to use templates?
    Templates are often used to:

    Create a type-safe collection class (for example, a stack) that can operate on data of any type.
    Add extra type checking for functions that would otherwise take void pointers.
    Encapsulate groups of operator overrides to modify type behavior (such as smart pointers).

    Most of these uses can be implemented without templates; however, templates offer several advantages:

    Templates are easier to write. You create only one generic version of your class or function instead of manually creating specializations.
    Templates can be easier to understand, since they can provide a straightforward way of abstracting type information.
    Templates are type-safe. Because the types that templates act upon are known at compile time, the compiler can perform type checking before errors occur.
    
41. How do you implement a singleton design pattern:    
    class playerManager
    {
        public:
            static playerManager& getInsance(){
                static playerManager instance;
                return instance;
            } 
        private:
            playerManager(){};
            playerManager(playerManager const&);   // Don't Implement.
            void operator=(playerManagerS const&); // Don't implemen
    };
    
    playerManager pm = playerManager::getInstance();
    
    * Make the constructor private. 
    * Make sure that you override the default copy constructor and assignment operator so that you can not make a copy of the singleton (otherwise it would not be a singleton).
    * You should never be able to free a singleton manually. How do you know who is keeping a reference to the singleton?
      If you don't know (or can't guarantee) nobody has a reference (in your case via a pointer) then you have no business freeing the object.
    * Use the static in a function method. This guarantees that it is created and destroyed only once. It also gives you lazy initialization for free. 
    



-------------------------------------------------------------------------------------
Scott Meyers:

28. Why is it a bad idea for destrucotrs to throw exception?
    try{ 
        vector<int> v; 
        fn1();
    }
    Now imagine fn1() throws an exception and then if vector<int>'s destructor also throws an exception, 
    then it is perfect receipe for a disaster.


27. Four functions that compiler generates for you: constructor, destructor, copy assignemnt, copy constructor.      

33. Always prefer psss const pass-by-reference over pass by value. Exceptions are: built-in variables and iterators.
    Iterators are very small. So, there is no advantage to passing by reference.


*. Design guidelines:
    1. Make interfaces such that it is easy to use correctly and hard to use incorrectly.    
    
   Public means uncapsulated which means unchangeable. 

29. Never call virtual functions in constructor/destructor becaseu this will end up calling the base class constructor 
    and never go to derived part.    
    
30. Assignment operator should return *this. This way we can do x = y = z;(y = z should return *this/y)    

32. In C++ iterators are implemented as pointers internally.


34. Problems in returning a reference: 
    stack allocated: you are pointing to nowhere.
    Heap allocated: YOu may not have the right reference to it.
    allocated using static inside a function: thread safety + other issues.
    Overall very bad idea to have a function that returns a reference. Always return by value/object.   

        
-------------------------------------------------------------------------------------
Design Patterns:

* Four types of design patterns: 
    * Creational - Factory 
    * Structural - Proxy
    * Behavioral - Observer, Mediator, Memento
    * Concurrency - Scheduling    
    

* Design patterns:
    1. Name 2. Problem(context where it might be applied). 3. Solution(defines objects and describes how they interact). 
    4. Consequences: Results and tradeoffs.   


----------------------------------------------------------------------------------
Array/string sizes and index

no of elements/size(including current index) = currIndex - startIndex;
no of elements/size(excluding current index) = currIndex - startIndex - 1;

Dummy nodes/Sentinel: very good when you want to have a dummy node in front of a linked list

---------------------------------------------------------------------------------
Bit wise operator:
1. Turn ON a bit(HONOR)
   x |= 0x01 => LSB is turned ON.
   x |= (1 << n) => nth bit in the variable x is turned ON. n is no of moves.
        (x >> n) => x is moved to RIGHT by n no of moves.
2. Turn OFF a bit(OFFENDNOT)
   x &= ~(1 << n) => nth bit is turned OFF
3. To test a bit is ON.
   if(x & (1 << n)) => TRUE is nth bit is ON
4. Toggle a bit:
   x ^= (1 << n) => nth bit is flipped/toggled.
5.        OR   AND  XOR(when two are distinct)
    0  0   0   0    0   
    0  1   1   0    1
    1  0   1   0    1
    1  1   1   1    0
    
    
---------------------------------------------------------------------------------
C/Embedded interview questions:

*  Never do the following(wasted an hour on this):
   for(unsigned char i = 0; i <= 255; i++){
   }
   Your for loop is spinning forever as i is always between 0 and 255.
*. What are the problems with C macros?
   1. They are not typesafe. There is nothing preventing you from passing in a character to 
      a macro that was desgined for int.
   2. Expressions passed to macros might evaluate more than one time.     
   3. C++ min macr is type safe.
  
*  C various declarations:
   1. An  array of 10 pointers to integers: int *ptr[10]
   2. A pointer to an array of 10 integers: int (*ptr)[10];
   3. A pointer to a function that takes an integer as an argument and returns an integer: 
      typedef int (*func_p)(int)  ;
      int myFunction(int){}
      func_p fp = myFunction;
    4. An array of 10 pointers to functions that takes an integer as an argument and returns an integer: 
      typedef int (*func_p)(int)  ;
      func_p fp[10]; 
    
                                                                                      
      
*  What do you mean by volatile:
   The value of this field might change outside this program without the compiler being aware of. 
   So, you are telling the compiler dont cache this value and always read it from memory.
   
*  Variable should be declared volatile whenever its value could change unexpectedly. In practice, only three types of variables could change:
   1. Memory-mapped peripheral registers
   2. Global variables modified by an interrupt service routine
   3. Global variables accessed by multiple tasks within a multi-threaded application


* DMA transfer begins
  * Cache content is not valid for the DMA buffer
  * DMA transfer is done. Processor is notifed with an intrrupt.
  * ISR is invoked. Context switch causes cache to be invalidated.
  * When you return from ISR you do a context swtitch again and you should be able to do a valid read from a DMA buffer.
  * Hardware ddoes all the cache management.

* ISR context: Supervisor/privileged context is where the ISR runs.
* Mask interrupts if they are irritiating you
* How do you achieve executing flash at the same time you are downloading?
  1. You have an external flash and internal flash.
  2. Code is running off internal flash at any time.
  3. External flash has two sections: One for current running code image and the other for any new image.
  4. When there is a new image, it gets downloaded into the external flash's appropriate section.
  5. Bootloader now runs off RAM and then it loads the new image onto the internal flash.
  6. After loading the new image onto internal flash, bootloader transfers control to the newly loaded internal flash image.
  7. If anything is problem with newly loaded image then bootloader erases the newly loaded image and transfers the old image.



---------------------------------------------------------------------------------
C++ memory model/Concurrency:

Producer-Consumer problem:
Two main problems:
1. Producer should sleep when the buffer is full. Consumer should sleep when the buffer is empty.
   Consumer should wake up there is 1 unit of data in the buffer. Producer should wake up when there
   is one unit of space available in the buffer. We should achieve this by producer and consumer 
   sending signal to each other. If this is not done properly we might end up sleeping forever.
2. You should properly protect the field that indicates how much data is present in a buffer using a 
   proper mutex. 
   
   For one you should use a condition variables. But, then condition variables also have to be properly
   protected using a mutex.
   
3. Primitives for protecting access to portions of memory: Mutex
   Primitives for allowing synchronization(block one thread until the other one does something) 
     between threads: Condition Variables. 
   A condition variable must always be paired with a mutex. When it waits for a mutex, it gives up the condition variable. 
   when the condition is met, it automatically gets themutex back again.   
      
4. Deadlock: Two threads waiting for a resource the other thread has. Infinite wait.
   Livelock: Each deadlocked thread releases the acquired resource and does something else. After sometime deadlock repeats.
             Then they go back to release the resource. They will back and forth forever like this. Lots of wasted cpu cylces.  
   Starvation: One thread has a resource and holds onto it forever. The other thread just keeps waiting. The one that is waiting 
             is basically starving.          

---------------------------------------------------------------------------------
Video Notes:

H.264:
 1. What are frames? I, P and B.
    Independent frame. Least compresed. You dont need other frames to decode it.
    P frame. Needs previous frames to decode it. It uses the I frame that comes before it to decode the frame. More compressed that IFrame
    B frame. can use previous a forward to decode it. It uses the I frame that comes before it and after it to decode itself. Most compressed.
    A slice: It is more spatial term. Is a spatially distinct region of a frame that is encoded separately from any other region in the same frame. 
    There are I-slices, P-slices, and B-slices.
 2. Profiles and levels?
    Profiles address the problem of code complexity and processing power.
    BMH:
    CEll phone use baseline
    STBs use Main Profile.
    Blueray uses high profile.
    Levels address the problem of bandwidth, max resolution, and memory issues on the decoder side
    Low end device(processor and memory), low bitrate, small screen size: go for baseline profile and lower levels
    High end device(processor and memory), high bitrate, bigger screen size: go for aseline profile and lower levels
     
 3. How do you reduce data?  Within and image and within a series of images.
 4. What is block based coding? Or what are macroblocks?
    Macro block is a processing unit.
 5. What block based motion compensation? What is coding the motion vector? (P frames)
 6. What is intra-prediction?
 * Most efficient encoder. In terms of bit-rate.
 * Also very high resilience to error.
 
HLS:

DASH:
  Media Presentation Desription File contains link to period description files.
  Period files contain link to Adapatation description files(camera angle, language etc).
  Adaptation description files contain link to bitrate info files.
  Bit rate info files contain link to actual video files(fragemented Mp4 files)
  
Comparison between HLS and MPEG DASH:
  HLS is sclable, Hard with MSE, and highest latency.  
MP4:


* Acceptable 1080p stream using H.264 (AVC) compression at around 6 Mbps. 
  All else being equal, a 4K video would require 4x the bandwidth of a 1080p video (24 Mbps).
  With efficient Codec you can bring it down to 15mbps. With Mediamelon you can bring it to 10mbps.
  
  
* Latest Video  - HLS/DASH using MSE. 
                  Codes: VP9, HEVC h.265 for low latency video coding, and then there is AV1 codec which is 20% more efficient than VP9. 
  
* Norbert questions:
  * What all hardware configurations we do? What is prerolling from device point of view?
  * How does Iframe only mode work?
  * fmp4 against regular MP4 
  * How do you initialize flow proxy and decoder proxy? What is the difference at a high level?
  * How do we play with buffering level etc in the case of newer pipeline?
    Water mark model?
    In our case when would we show the spinning wheel"
    High water mark and lowe water mark: We start playing when we reach the high water mark. 
    But, we would pause when we go below the low water mark. Wait unti we hit the high water mark gain.
  * Licensing terms.
  * Do you know anything about GStreamer's streaming threads.
  * We were disabling prerolling after the first playback. Becuase of this after a seek we were not 
    able to wait for ASYNC_DONE message.
  
  
-----------------------------------------------------------------------------------------------------------------------------------    

UTF/Unicode


-----------------------------------------------------------------------------------------------------------------------------------    
  
    
-----------------------------------------------------------------------------------------------------------------------------------    
  * Networking:
   Unicast: from one source to one destination i.e. One-to-One 
   Broadcast: from one source to all possible destinations i.e. One-to-All 
   Multicast: from one source to multiple destinations stating an interest in receiving the traffic i.e. One-to-Many 
   
   Why TCP against UDP for VoD streaming:
   1. TCP provides reliability. Sends the packet again if there is a drop of packet.
   2. TCP provides network buffers.
   3. TCP connections oriented. So, helps with security.
   4. TCP's bandwidth probing and congestion control will attempt to use all of the available 
      bandwidth between server and client, fetching content as quick as possible while being friendly
      to other (TCP) traffic on the same links.
      
   Other advantages of TCP:
   * in-order delivery of data to the application. 
   * Since TCP builds a buffer, TCP also has to ensure that its buffer does not overflow. This is ensured using 
     flow-control where receiver tells the sender if the buffer is full.
   * TCP offers congestion control. It means keeps increasing its send buffer window sizes until 
     it sees packet drops.  
   * With TCP server needs a socket connection for every TCP receivert where as with UDP server can talk to multiple UDP receivers
     using the same socket.   
      
   RTSP: Realtime streaming protocol. Session control protocol for streaming video. TCP based.
   RTP: Realtime Trasport protocol. used with RTSP to stream video data. UDP based.
   RTCP: Realtime Trasport Control protocol. Goes with RTP. It provides QoS for RTP.
   RTMP: Realtime Messaging protocol. RTMP is a TCP-based protocol which maintains persistent connections and allows low-latency communication.
         Unlike HLS, RTMP uses a push model. Instead of the player requesting each segment, the server continuously sends video and audio data
     
   What is the difference between HTTP POST and PUT
   PUT is replacing the current website(look and feel). Shivani - Put is update. I want to add.
   Post is adding some content to fields of a document. POST is modify an existing field. I want to change my address.
-----------------------------------------------------------------------------------------------------------------------------------

Bufferuing Using Gstreamer:
1. Application PAUSES the pipeline when it sees a buffering % below 100%.
2. Application PLAYSBACK using the pipeline when it sees a buffering = 100%.
* How does the application receive this message? The pipeline has to send it. How does the pipeline do it?
  It can have a low and high water mark. When the buffer level hits the high water mark, we can send the 100% message. 
  When it goes below the low water mark, it sends less than 100% message. It will wait until hits the high water mark again to send 100%.
* How do you configure the low and high water marks?
  1. Fixed time: We always want buffer for these many seconds.
  2. Fixed size: We always want buffer these many bytes.
* NULL state: Default state.
* READY state: Default resources(run-time libraries and memory) available. NULL to ready, allocate all non-stream specific resources.
* PAUSED state: It is ready and can handle data.    

GStreamer High Level Flow:
1. Initialize an element(class init/bin init)
2. Set properties.
3. State Trasitions: Tells when to allocate resources.
                      NULL to ready - Memory, library etc(All proxies: resman, winman, flowproxy).
                      READY to PAUSED - Decoder resource allocation.
                       
4. Once in paused state, it can receive events(seek, caps, newsegment event)
   caps event says what kind of decoder it is?
   newsegment indicates samples from new duration.
5. Chain calls. Receives video samples..
6. Now you can send messages to bus.
7. Answer any query like duration etc.
8. somebody can do a get property call.

* Scheduling mode: At OTV We did a push based shceduling mode. The src element would create a thread and push. Src pad would receive the chain function and in turn do a 
  a push of data on their sink pad.
  Pull based mode, the src pad would start a task and every src pad would support a function where you would get a range of bytes. 
  This would be used in cases where downstream element wants the control the data flow and requests only those many byes from the 
  upstream element.


-----------------------------------------------------------------------------------------------------------------------------------

System design:

Measure stck usage:
Design malloc:



